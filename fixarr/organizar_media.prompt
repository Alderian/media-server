Actu√° como un **experto desarrollador Python y experto en organizaci√≥n de bibliotecas multimedia**. Ten√©s acceso al c√≥digo completo en el directorio local del proyecto `fixarr` de este repo: https://github.com/Alderian/media-server dentro de la carpeta `fixarr`. El objetivo es **mejorar, refactorizar, configurar y hacer muy f√°cil de usar** la herramienta que ordena archivos de pel√≠culas, series y m√∫sica desde consola (por ejemplo en una Raspberry Pi). Deb√©s analizar el c√≥digo actual y hacer todos los cambios necesarios seg√∫n la siguiente lista de mejoras y reglas de negocio.

### CONTEXTO DE USO
La herramienta actual intenta:
- escanear un directorio
- identificar tipo de medios (pel√≠culas, series, m√∫sica)
- mover los archivos a carpetas destino
- renombrarlos seg√∫n metadata remota
Pero el resultado tiene:
- falsos positivos (por ejemplo `Klaus` fue mal identificado),
- archivos sin metadata usados de todas formas,
- patrones de nombre no configurables,
- falta de tratamiento de archivos no reconocidos,
- falta de mecanismos de *confidence scoring* y *fallback*,
- configuraci√≥n de formatos de nombre no editable,
- falta de separaci√≥n clara de l√≥gica de negocio.

Vos ten√©s que **generar TODO lo necesario** para mejorar y complementar el proyecto.

---

## üß© OBJETIVOS PRINCIPALES

### 1) Normalizaci√≥n y extracci√≥n de t√≠tulos
- Cre√° o mejor√° funciones que limpien nombres de archivo antes de buscar metadata (sacar resoluciones, codecs, tags de idioma, texto extra).
- Implement√° una funci√≥n `clean_media_filename(raw)` que devuelva un t√≠tulo base y a√±o (**sin interactuar con el usuario**) para usar en las consultas a APIs como TMDb/IMDb/TVmaze.
- Us√° regex y heur√≠sticas claras.

### 2) Metadata remota con scoring y reglas de confianza
- Reemplaz√° la l√≥gica actual de tomar *primer resultado* con un *scoring* que eval√∫e:
  - similitud de t√≠tulo (fuzzy matching),
  - coincidencia de a√±o,
  - coincidencias de palabras claves,
  - longitud de t√≠tulo.
- Si el *score* es insuficiente (< configurable threshold), **no mover el archivo a su destino final**.
- En esos casos mov√© el archivo a una carpeta especial de **revisi√≥n pendiente** dentro de `dst/review_needed/`.

### 3) Configurabilidad de formatos de nombre
- Implement√° un sistema de configuraci√≥n (archivo JSON o YAML) con un esquema como:

```yaml
naming:
  # Movies: {title}, {year}, {imdb_id}, {tmdb_id}
  movie_folder: "{title} ({year}) [imdbid-{imdb_id}]"
  movie_file: "{title} {(year)} [imdbid-{imdb_id}] - {{Edition Tags}} {[MediaInfo 3D]}{[Custom Formats]}{[Quality Full]}{Mediainfo AudioCodec}-{Mediainfo AudioChannels}{[MediaInfo VideoDynamicRangeType]}{[MediaInfo VideoCodec]}{-Release Group}"

  # TV Shows: {title}, {year}, {imdb_id}, {tmdb_id}, {season}, {episode}, {episode_title}
  tv_show_folder: "{title} ({year}) - [imdb-{imdb_id}]"
  tv_season_folder: "Season {season:02d}"
  tv_file: "{title} ({year}) - S{season:00}E{episode:00} - {episode_title} - {MediaInfo AudioLanguagesAll} subs {MediaInfo SubtitleLanguages} {Edition Tags} {[Custom Formats]}{[Quality Full]}{-Release Group}"

  # Music: {artist}, {album}, {year}, {track_number}, {track_title}
  music_artist_folder: "{artist}"
  music_album_folder: "{album} ({year})"
  music_track_file: "{track_number} - {track_title}"
````

* El c√≥digo debe leer esa configuraci√≥n y usarla para construir la ruta de destino y nombre de archivo.
* Permit√≠ que el usuario edite este archivo para personalizar nombres.

### 4) Manejo de archivos no reconocidos

* Si un archivo no se puede clasificar (sin metadata decente y sin nombre claro):

  * No se debe mover a la estructura final.
  * Debe moverse a `dst/review_needed/`.
  * Debe quedar anotado en el reporte con sugerencias de nombres candidatos y los *scores* que se calcularon.

### 5) Reporte detallado

* Gener√° un `report.json` con:

  * lista de archivos procesados,
  * metadata encontrada,
  * decisi√≥n tomada,
  * score y por qu√© se rechaz√≥ (si fue rechazado),
  * ruta final o ruta de revisi√≥n pendiente.

### 6) Extra features sugeridas con alternativas CLI open source

Adopt√° o inspirate en alguna de estas herramientas (como CLI integrables) para usos de renombrado o metadata:

* **MediaMovarr**: organiza media seg√∫n est√°ndares Plex/Kodi/Jellyfin con TMDb opcional. ([PyPI][1])
* **Shownamer**: renombra archivos de TV/Movies con OMDb/TVmaze y soporta templates de formato. ([PyPI][2])
* **mnamer**: altamente configurable, con plantillas poderosas y soporte TMDb/OmDb. ([PyPI][3])
* **imdb-rename**: renombra basado en nombres indexados de IMDb (disponibles en CLI). ([GitHub][4])
* **tvmv**: CLI para renombrar episodios con TMDb. ([GitHub][5])

Pod√©s:

* incorporar funciones de esas librer√≠as (por ejemplo integrar mnamer internamente),
* o generar wrappers CLI que usen esas herramientas internamente para tareas de renombrado o scoring.

### 7) M√∫sica y subt√≠tulos

* Para m√∫sica, integr√° *beets* o similar pero no dependa de interacci√≥n.
* Para subt√≠tulos, vincul√° autom√°ticamente archivos `.srt/.vtt/.ass` con el archivo de v√≠deo correspondiente seg√∫n el idioma y renombrado.

### 8) Modularizaci√≥n y pruebas

* Reestructur√° el proyecto por m√≥dulos:

  * `scanner.py`
  * `name_cleaner.py`
  * `metadata.py` (con scoring)
  * `organizer.py`
  * `config.py`
  * `report.py`
  * `main.py` (CLI con argparse)
* Agreg√° tests unitarios en `tests/` para cada m√≥dulo.
* Inclu√≠ documentaci√≥n y ejemplos de configuraci√≥n.

### 9) UX de CLI

* CLI debe tener:

  * flags: `--src`, `--dst`, `--config PATH`, `--dry-run`, `--report PATH`, `--verbose`.
  * Dry-run modo que simula y muestra cambios sin mover nada.
  * Verbose detallado con score y heur√≠sticas.
  * Valores configurables por .env o archivo de configuraci√≥n para las api keys y para los directorios origen y destino por defecto.

---

## üèÅ SALIDA ESPERADA

La IA debe modificar el repositorio directamente y dejarlo listo para:

* instalar dependencias (`requirements.txt`),
* correr en Raspberry Pi,
* soportar configuraci√≥n de nombres,
* procesar sin interacci√≥n,
* mover autom√°ticamente archivos con baja tasa de falsos positivos,
* generar reportes claros y reutilizables.

El c√≥digo debe ser limpio, bien documentado (docstrings), y acompa√±ado de tests. Tambi√©n debe tener `README.md` actualizado con instrucciones de uso. Todos los comentarios deben estar en ingles, todos los docstrings deben estar en inglestodos los README, AGENTS.md, etc en ingles.

---

## üìå RESTRICCIONES

* El proceso **no debe solicitar entrada del usuario** durante el ordenamiento final (todo debe ser heur√≠stico + configurable). Y si el proceso no tiene certeza de algo, debe dejar los archivos separados y un log de lo que no pudo hacer.
* La IA puede **buscar alternativas open source**, usar funciones de esos proyectos (referenciarlos en el c√≥digo) o generarlas desde cero.
* La IA debe operar bajo el supuesto de que puede *leer y escribir archivos en el proyecto local*.

---

## üõ†Ô∏è Opciones de API y bases de datos

Deb√©s usar:

* TMDb para pel√≠culas/series con tu propia API key,
* TVmaze o TVDb para episodios (el que tenga mejor cobertura),
* IMDb como fallback o con herramientas como imdb-rename.

---

## üìù Finaliz√° diciendo ‚Äú**changes complete**‚Äù cuando hayas terminado.

---

[1]: https://pypi.org/project/mediamovarr/?utm_source=chatgpt.com "mediamovarr ¬∑ PyPI"
[2]: https://pypi.org/project/shownamer/?utm_source=chatgpt.com "shownamer ¬∑ PyPI"
[3]: https://pypi.org/project/mnamer/?utm_source=chatgpt.com "mnamer ¬∑ PyPI"
[4]: https://github.com/BurntSushi/imdb-rename?utm_source=chatgpt.com "GitHub - BurntSushi/imdb-rename: A command line tool to rename media files based on titles from IMDb."
[5]: https://github.com/keithfancher/tvmv?utm_source=chatgpt.com "GitHub - keithfancher/tvmv: Bulk-rename TV episode files with minimal fuss"
